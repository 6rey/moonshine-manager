// main.js - Основной процесс Electron
const { app, BrowserWindow, ipcMain } = require('electron');
const path = require('path');
const axios = require('axios');
// require('dotenv').config(); // загружаем .env
const jwt = require('jsonwebtoken');
const https = require('https');
const agent = new https.Agent({ rejectUnauthorized: false });

const axiosInstance = axios.create({
  baseURL: 'https://192.168.116.11',   // URL‑сервера
  timeout: 10000,
  httpsAgent: agent,               // <-- отключаем проверку
});

module.exports = { axiosInstance };  // используйте позже вместо простого axios

// Конфигурация API
const API_CONFIG = {
  BASE_URL: process.env.VUE_APP_API_URL || 'https://192.168.116.11',
  LOGIN_PATH: '/auth/token',
  USERS_PATH: '/admin/users',
  VMS_PATH: '/vm/list',
  ASSIGNMENTS_PATH: '/vm/assignments',
  ASSIGN_PATH: '/vm/assign',
  UNASSIGN_PATH: '/vm/unassign',
  PREPARE_PAIRING_PATH: '/vm/prepare-pairing',
  COMPLETE_PAIRING_PATH: '/vm/complete-pairing'
};

let mainWindow;
let token = null;
let currentUser = null;
let userRole = null;

// Функция для создания окна приложения
function createWindow() {
  mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js')
    }
  });

  mainWindow.loadFile('renderer.html');

  // Открыть DevTools в режиме разработки
  if (process.env.NODE_ENV === 'development') {
    mainWindow.webContents.openDevTools();
  }
}

// Функция для отправки логов в renderer process
function sendLog(level, message, data = null) {
  const timestamp = new Date().toLocaleTimeString();
  const logEntry = {
    timestamp,
    level, // 'info', 'success', 'error', 'warning'
    message,
    data
  };

  if (mainWindow && !mainWindow.isDestroyed()) {
    mainWindow.webContents.send('log-message', logEntry);
  }

  // Also log to console
  console.log(`[${timestamp}] [${level.toUpperCase()}] ${message}`, data || '');
}

// Функция для выполнения API запросов
async function fetchAPI(endpoint, options = {}) {
  const url = `${API_CONFIG.BASE_URL}${endpoint}`;

  sendLog('info', `API Request: ${options.method || 'GET'} ${endpoint}`);

  try {
    // здесь используем уже созданный экземпляр
    const response = await axiosInstance({
      url,
      ...options,
      headers: {
        ...options.headers,
        ...(token ? { Authorization: `Bearer ${token}` } : {})
      }
    });

    sendLog('success', `API Response: ${options.method || 'GET'} ${endpoint} - Status ${response.status}`);
    return response.data;
  } catch (error) {
    const errorMsg = error.response?.data?.detail || error.message;
    sendLog('error', `API Error: ${options.method || 'GET'} ${endpoint}`, errorMsg);
    console.error('API Error:', error.response?.data || error.message);
    throw error;
  }
}

// Обработчики IPC событий
ipcMain.handle('login', async (event, { username, password }) => {
  try {
    sendLog('info', `Login attempt for user: ${username}`);
    const data = await fetchAPI(API_CONFIG.LOGIN_PATH, {
      method: 'POST',
      data: { username, password }
    });

    token = data.access_token;

    // Декодируем токен для получения информации о пользователе
    const decoded = jwt.decode(token);
    currentUser = decoded.sub;
    userRole = decoded.role;

    sendLog('success', `User ${currentUser} logged in successfully (Role: ${userRole})`);
    return { success: true, token, user: currentUser, role: userRole };
  } catch (error) {
    sendLog('error', `Login failed for user: ${username}`, error.response?.data?.detail);
    return { success: false, error: error.response?.data?.detail || 'Authentication failed' };
  }
});

ipcMain.handle('get-users', async () => {
  try {
    const users = await fetchAPI(API_CONFIG.USERS_PATH, { method: 'GET' });
    return { success: true, users };
  } catch (error) {
    return { success: false, error: error.response?.data?.detail || 'Failed to load users' };
  }
});

ipcMain.handle('get-vms', async () => {
  try {
    const vms = await fetchAPI(API_CONFIG.VMS_PATH, { method: 'GET' });
    return { success: true, vms };
  } catch (error) {
    return { success: false, error: error.response?.data?.detail || 'Failed to load VMs' };
  }
});

ipcMain.handle('get-assignments', async () => {
  try {
    const assignments = await fetchAPI(API_CONFIG.ASSIGNMENTS_PATH, { method: 'GET' });
    return { success: true, assignments };
  } catch (error) {
    return { success: false, error: error.response?.data?.detail || 'Failed to load assignments' };
  }
});

ipcMain.handle('create-user', async (event, userData) => {
  try {
    const user = await fetchAPI('/auth/register', {
      method: 'POST',
      data: userData
    });
    return { success: true, user };
  } catch (error) {
    return { success: false, error: error.response?.data?.detail || 'Failed to create user' };
  }
});

ipcMain.handle('delete-user', async (event, userId) => {
  try {
    await fetchAPI(`/admin/user/${userId}`, { method: 'DELETE' });
    return { success: true };
  } catch (error) {
    return { success: false, error: error.response?.data?.detail || 'Failed to delete user' };
  }
});

ipcMain.handle('assign-vm', async (event, assignmentData) => {
  try {
    await fetchAPI(API_CONFIG.ASSIGN_PATH, {
      method: 'POST',
      data: assignmentData
    });
    return { success: true };
  } catch (error) {
    return { success: false, error: error.response?.data?.detail || 'Failed to assign VM' };
  }
});

ipcMain.handle('unassign-vm', async (event, unassignData) => {
  try {
    await fetchAPI(API_CONFIG.UNASSIGN_PATH, {
      method: 'DELETE',
      data: unassignData
    });
    return { success: true };
  } catch (error) {
    return { success: false, error: error.response?.data?.detail || 'Failed to unassign VM' };
  }
});

ipcMain.handle('prepare-pairing', async (event, vmId) => {
  try {
    const data = await fetchAPI(API_CONFIG.PREPARE_PAIRING_PATH, {
      method: 'POST',
      data: { vm_id: vmId }
    });
    return { success: true, ...data };
  } catch (error) {
    return { success: false, error: error.response?.data?.detail || 'Failed to prepare pairing' };
  }
});

ipcMain.handle('complete-pairing', async (event, pairingData) => {
  try {
    const data = await fetchAPI(API_CONFIG.COMPLETE_PAIRING_PATH, {
      method: 'POST',
      data: pairingData
    });
    return { success: true, ...data };
  } catch (error) {
    return { success: false, error: error.response?.data?.detail || 'Failed to complete pairing' };
  }
});

// Жизненный цикл приложения
app.whenReady().then(() => {
  createWindow();

  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) {
      createWindow();
    }
  });
});

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});
